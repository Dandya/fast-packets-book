# Обзор системы AF_PACKET

***

В данном разделе разбирается устройство системы AF_PACKET, а также примеры её использования.

1. [Введение](#введение)
2. [Описание архитектуры](#описание-архитектуры)
  1. [Применяемые механизмы и технологии](#применяемые-механизмы-и-технологии)
  2. [Доступные режимы](#доступные-режимы)
  3. [Процесс передачи сетевых пакетов]()
3. [Разбор примеров]()
  1. [Захват сетевых пакетов]()
  2. [Отправка сетевых пакетов]()
4. [Заключение]()
5. [Полезные материалы]()
6. [Источники]()

***

## Введение

При упоминании термина «захват сетевых пакетов» первое, что приходит на ум большинству — это программы «Wireshark», «Tcpdump» или библиотека «Libpcap». Но все эти механизмы захвата сетевого трафика основываются на подсистеме «AF_PACKET» ядра «Linux».

Первая версия подсистемы появилась в версии ядра 2.0 в 1996 году, позволяя получать в пользовательском пространстве пакеты сетевого уровня с заголовком IP, что ограничивало практическое использование подсистемы. Сейчас же «AF_PACKET» предоставляет гибкий интерфейс для захвата сетевых пакетов на канальном уровне и передачи их на другие интерфейсы для отправки на скорости до 10 Гб/с.

## Описание архитектуры

### Применяемые механизмы и технологии

Система «AF_PACKET» основывается на интерфейсе сокетов ядра «Linux». Полученные пакеты, хранящиеся в структурах `sk_buff` передаются в «AF_PACKET», откуда посредством отображения памяти через `mmap` или с помощью системных вызовов `recvfrom/sendto` передаются в пользовательское пространство [1].

### Доступные режимы

Передача пакетов доступна в системе «AF_PACKET» в двух видах:

1. `SOCK_RAW` — пакеты с заголовком канального уровня;
2. `SOCK_DGRAM` — пакеты без заголовка канального уровня.

Для получения или отправки пакетов используются системные вызовы `recvfrom/sendto`, что сильно нагружает систему. Поэтому с версии ядра 2.4 появилась возможность использования общей памяти между ядром и пользовательским пространством, что сильно уменьшает накладные расходы на передачу пакетов между пространствами. Этот механизм получил название «PACKET_MMAP» и представляет собой кольцевой буфер сетевых пакетов.

Чтобы перейти от системных вызовов к общей памяти, необходимо с помощью системного вызова `setsockopt`  передать параметры кольцевого буфера командой `PACKET_RX_RING` на уровне `SOL_PACKET`. По умолчанию создаётся кольцо первой версии `TPACKET_V1`, но чтобы создать кольцо более современной версии необходимо также с помощью системного вызова `setsockopt` передать нужную версию командой `PACKET_VERSION` на уровне `SOL_PACKET`.

Рассмотрим различия всех трёх версий работы механизма «PACKET_MMAP»:

1. В версии `TPACKET_V1`:
     - Доступны кольца RX и TX;
     - Доступно время получения пакета с точностью до миллисекунд;
     - Метаданные пакета доступны через структуру `tpacket_hdr`.
2. В версии `TPACKET_V2`:
     - Доступно время получения пакета с точностью до наносекунд;
     - Доступна информация о VLAN;
     - Метаданные пакета доступны через структуру `tpacket2_hdr`.
3. В версии `TPACKET_V3`:
     - Передача сетевых пакетов блоками (наборами);
     - Доступна динамическая настройка размера блока;
     - Доступна настройка времени ожидания новых пакетов;
     - Доступна информация о VLAN;
     - Метаданные пакета доступны через структуру `tpacket3_hdr`.

Также с версии ядра «Linux» 3.1 стала доступна команда `PACKET_FANOUT`, которая позволяет настроить балансировку нагрузки, распределяя полученные пакеты по очередям и избегая синхронизации данных между процессорами, потоками. Доступны следующие значения:

1. `PACKET_FANOUT_HASH` — распределение пакетов на основе хеша из адресов, портов и номера протокола транспортного уровня;
2. `PACKET_FANOUT_LB` — циклическое распределение пакетов по очередям;
3. `PACKET_FANOUT_CPU` — привязка к номеру логического процессора, что позволяет избежать блокировок для синхронизации данных;
4. `PACKET_FANOUT_RND` — случайное распределение по очередям;
5. `PACKET_FANOUT_ROLLOVER` — заполнение очередей в зависимости от их заполненности;
6. `PACKET_FANOUT_QM` — привязка к очередям сетевой карты;
7. `PACKET_FANOUT_CBPF` — распределение на основе классического BPF (см. [фильтрация пакетов](BPF.md));
8. `PACKET_FANOUT_EBPF` — распределение на основе расширенного BPF (см. [фильтрация пакетов](BPF.md));
9. `PACKET_FANOUT_FLAG_DEFRAG` — дополнительный параметр, который включает дефрагментацию пакетов IP до передачи их в сокет;
10. `PACKET_FANOUT_FLAG_ROLLOVER` — дополнительный параметр, который распределяет пакет в следующую очередь, если нужная заполнена.

### Процесс передачи сетевых пакетов

Описать, как в linux/net/packet/af_packet.c реализованы захват и отправка пакетов.

## Разбор примеров

Рассмотрим теперь работу с системой «AF_PACKET» из пользовательского пространства. Все примеры по использованию системы приведены в директории `/src/af_packet` в данном репозитории.

### Настройка сокета



### Захват сетевых пакетов

### Отправка сетевых пакетов

## Источники

1. [Описание системы «AF_PACKET»](https://man7.org/linux/man-pages/man7/packet.7.html)
2. [Документация ядра «Linux» о механизме «PACKET_MMAP»](https://www.kernel.org/doc/html/latest/networking/packet_mmap.html)
